#!/usr/bin/env node

/**
 * Migration Script: Add Employee IDs to Existing Users
 *
 * This script adds employeeId field to all existing User documents.
 * Employee IDs follow the pattern: M + numbers (e.g., M361549)
 *
 * Usage:
 *   node addEmployeeIdToUsers.js
 *
 * Options:
 *   1. Auto-generate sequential IDs (M000001, M000002, etc.)
 *   2. Use actual employee IDs (edit EMPLOYEE_ID_MAP below)
 */

const mongoose = require('mongoose');
require('dotenv').config({ path: require('path').resolve(__dirname, '../../.env') });

const User = require('../models/User');

// ============================================================================
// CONFIGURATION
// ============================================================================

/**
 * Set to true to use actual employee IDs from EMPLOYEE_ID_MAP
 * Set to false to auto-generate sequential IDs (M000001, M000002, etc.)
 */
const USE_ACTUAL_IDS = false;

/**
 * Map email addresses to actual employee IDs
 * Only used if USE_ACTUAL_IDS = true
 */
const EMPLOYEE_ID_MAP = {
  // Example:
  // 'john.smith@example.com': 'M361549',
  // 'jane.doe@example.com': 'M123456',
};

/**
 * Starting number for auto-generated IDs
 * Only used if USE_ACTUAL_IDS = false
 */
const AUTO_ID_START = 1;

// ============================================================================
// MIGRATION FUNCTIONS
// ============================================================================

/**
 * Generate a sequential employee ID
 * @param {number} index - The sequence number
 * @returns {string} Employee ID (e.g., M000001)
 */
function generateEmployeeId(index) {
  const paddedNumber = String(index).padStart(6, '0');
  return `M${paddedNumber}`;
}

/**
 * Main migration function
 */
async function migrateUsers() {
  try {
    console.log('üîó Connecting to MongoDB...');
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('‚úÖ Connected to MongoDB\n');

    // Fetch all users
    console.log('üìã Fetching all users...');
    const users = await User.find({}).sort({ createdAt: 1 });
    console.log(`Found ${users.length} users\n`);

    if (users.length === 0) {
      console.log('‚ÑπÔ∏è  No users found. Nothing to migrate.');
      return;
    }

    // Separate users into those with and without employeeId
    const usersWithEmployeeId = users.filter(u => u.employeeId);
    const usersWithoutEmployeeId = users.filter(u => !u.employeeId);

    console.log(`‚úÖ Users already with employeeId: ${usersWithEmployeeId.length}`);
    console.log(`‚ö†Ô∏è  Users needing employeeId: ${usersWithoutEmployeeId.length}\n`);

    if (usersWithoutEmployeeId.length === 0) {
      console.log('‚úÖ All users already have employeeId. Nothing to migrate.');
      return;
    }

    // Display existing employeeIds (if any) for reference
    if (usersWithEmployeeId.length > 0) {
      console.log('üìã Existing Employee IDs:');
      usersWithEmployeeId.forEach(u => {
        console.log(`   ${u.employeeId} - ${u.email} (${u.firstName} ${u.lastName})`);
      });
      console.log('');
    }

    // Prepare updates
    console.log('üîÑ Preparing updates...\n');
    const updates = [];
    let autoIdCounter = AUTO_ID_START;

    // Find the highest existing auto-generated ID to avoid conflicts
    if (usersWithEmployeeId.length > 0 && !USE_ACTUAL_IDS) {
      const autoGeneratedIds = usersWithEmployeeId
        .map(u => u.employeeId)
        .filter(id => /^M\d{6}$/.test(id)) // Only auto-generated format
        .map(id => parseInt(id.substring(1), 10));

      if (autoGeneratedIds.length > 0) {
        const maxId = Math.max(...autoGeneratedIds);
        autoIdCounter = maxId + 1;
        console.log(`‚ÑπÔ∏è  Starting auto-generation from M${String(autoIdCounter).padStart(6, '0')}\n`);
      }
    }

    for (const user of usersWithoutEmployeeId) {
      let employeeId;

      if (USE_ACTUAL_IDS) {
        // Use actual employee ID from map
        employeeId = EMPLOYEE_ID_MAP[user.email];

        if (!employeeId) {
          console.warn(`‚ö†Ô∏è  WARNING: No employee ID mapped for ${user.email}`);
          console.warn(`   Skipping this user. Add to EMPLOYEE_ID_MAP or set USE_ACTUAL_IDS = false`);
          continue;
        }
      } else {
        // Auto-generate sequential ID
        employeeId = generateEmployeeId(autoIdCounter);
        autoIdCounter++;
      }

      // Validate format
      if (!/^M\d+$/.test(employeeId)) {
        console.error(`‚ùå ERROR: Invalid employee ID format: ${employeeId}`);
        console.error(`   Must match pattern: M followed by numbers (e.g., M361549)`);
        continue;
      }

      updates.push({
        user,
        employeeId
      });
    }

    if (updates.length === 0) {
      console.log('‚ùå No valid updates to perform.');
      return;
    }

    // Display planned updates
    console.log('üìã Planned Updates:');
    console.log('‚îÄ'.repeat(80));
    updates.forEach(({ user, employeeId }) => {
      console.log(`${employeeId} ‚Üê ${user.email} (${user.firstName} ${user.lastName})`);
    });
    console.log('‚îÄ'.repeat(80));
    console.log(`Total: ${updates.length} users\n`);

    // Confirm before proceeding
    console.log('‚ö†Ô∏è  This will modify user documents in the database.');
    console.log('Press Ctrl+C to cancel, or wait 5 seconds to continue...\n');

    await new Promise(resolve => setTimeout(resolve, 5000));

    // Perform updates
    console.log('üîÑ Updating users...\n');
    let successCount = 0;
    let errorCount = 0;

    for (const { user, employeeId } of updates) {
      try {
        // Check if employeeId already exists
        const existing = await User.findOne({ employeeId });
        if (existing) {
          console.error(`‚ùå ERROR: Employee ID ${employeeId} already exists for ${existing.email}`);
          console.error(`   Cannot assign to ${user.email}`);
          errorCount++;
          continue;
        }

        // Update user using updateOne to bypass required field validation
        await User.updateOne(
          { _id: user._id },
          { $set: { employeeId, updatedAt: Date.now() } }
        );

        console.log(`‚úÖ Updated: ${employeeId} ‚Üí ${user.email}`);
        successCount++;
      } catch (error) {
        console.error(`‚ùå ERROR updating ${user.email}:`, error.message);
        errorCount++;
      }
    }

    // Summary
    console.log('\n' + '='.repeat(80));
    console.log('üìä MIGRATION SUMMARY');
    console.log('='.repeat(80));
    console.log(`‚úÖ Successfully updated: ${successCount}`);
    console.log(`‚ùå Errors: ${errorCount}`);
    console.log(`üìã Total users in database: ${users.length}`);
    console.log(`‚úÖ Users with employeeId: ${usersWithEmployeeId.length + successCount}`);
    console.log('='.repeat(80));

    // Verify all users now have employeeId
    const remainingWithoutId = await User.countDocuments({ employeeId: { $exists: false } });
    if (remainingWithoutId > 0) {
      console.log(`\n‚ö†Ô∏è  WARNING: ${remainingWithoutId} users still without employeeId`);
    } else {
      console.log('\n‚úÖ SUCCESS: All users now have employeeId');
    }

  } catch (error) {
    console.error('\n‚ùå Migration failed:', error);
    throw error;
  } finally {
    await mongoose.connection.close();
    console.log('\nüîå Disconnected from MongoDB');
  }
}

// ============================================================================
// EXECUTE
// ============================================================================

if (require.main === module) {
  migrateUsers()
    .then(() => {
      console.log('\n‚úÖ Migration completed');
      process.exit(0);
    })
    .catch(error => {
      console.error('\n‚ùå Migration failed:', error);
      process.exit(1);
    });
}

module.exports = { migrateUsers };
